## 关于组合和继承

在日常的编程过程中，一些常用的功能都不需要我们自己从头来实现，只要使用已有的代码即可，这些代码可能来自于公司中其他的同事、第三方开源库或者自己曾经写的代码。这样不进提高了程序员的编码效率，也有力与编程语言相关生态的形成，所以几乎所有的编程语言都提供了代码复用的功能。

Java 语言中将代码组织成类的形式（我对其的简单理解是数据+函数），所以在 Java 中代码的复用也就是类的复用，具体有两种形式：一种是组合，一种是继承。

对我来说组合是比较容易理解的一件事情，因为组合的概念本身跟现实生活比较贴近，例如做一件事情的时候，可以把整件事情切分成不同的阶段，不同的阶段组合起来就构成了我们要完成的事情。我学的第一门编程语言是大学时的 C 语言，在有了一定的学习基础后，编程过程中我会下意识的把常用的一些代码片段写成函数，然后在需用的时候调用这些函数。当需要实现一些复杂功能的时候，我会尽可能通过组合已经实现的功能函数。

```C
int A() {
	// 完成某些功能
}

int B() {
	// 完成某些功能
}


// 通过调用已有函数实现功能
int C() {
	A()
	B()
}
```

上面的代码很好的展现了组合的思想，通过将已有内容的组合构建出新的内容，当然这并不是严格意义上的组合，因为组合是在面向对象的语言中提出的概念，而 C 语言是完全面向过程的。回归到 Java 中，代码以类的形式组织起来，所谓的组合就和就是在类的属性中有别的代码的实例，本质上还是通过将已有内容的组合构建出新的内容。

现实世界中组合对我们来说是司空见惯的，比如瓶子=瓶身+瓶盖、电脑=键盘+鼠标+主机+显示器，在 Java 中组合也采取了类似 C=A+B 这种简单粗暴的模式，例如下面的例子里，汽车=轮子+引擎。

```java
class Wheel {
}

class Engine {
}

class Car {
	private Wheel wheel;
	private Engine engine;
}
```

相对来说继承这个概念就比较抽象，通常继承这个词用在生物学上，用于表示两个个体之间的某种联系，比如我们与自己的父母之间会存在某种相似之处，外人可能很容易通过长相分辨出我们可能是谁的儿子或女儿，但即便如此我们和父母之间任然是相互独立的个体，我们是无法完美的顶替自己的父母在生产生活中的位置。在 Java 中的继承表示的更像是一种分类关系，子类属于父类中的某一种，比如狗这样一个父类中可以包含中华田园犬、哈士奇、藏獒等等, 任何需要狗的场景，都可以使用狗这个分类下的子类来代替。与此同时 Java 中的继承也包含一种生物学上继承的意味，父类中的方法和属性会被子类所继承, 这也是继承可以用来实现代码复用的原因。 

```java
class Dog {
	private String name;
}

class ZhongHuaTianYuanQuan extend Dog {
	// 继承Dog中的name
}

class HaShiQi extend Dog {
	// 继承Dog中的name
}

class ZangAo extend Dog {
	// 继承Dog中的name
}
```

在初次学习到类和继承的时候，我会想着无限度的用类模拟现实中对应的事物，最终都是失败而告终，这可能也是许多其他人遇到过的问题。问题的根源在于现实世界中的事物分类错综复杂，比如拖拉机，它是农业机械，是交通工具，也有可能变成历史文物，或者变成废品被回收，总之它具体属于哪个分类要根据不同的场合来判断。

Java 中在类的继承上采用了单继承，避免了继承时的混乱，这就限制了我们将同一事物归属到不同的分类中。我们编写代码的过程中要提取事物的部分主要特征，在田间地头时，拖拉机就属于农用机械，其他的都不需要考虑。Java 这样设计看似阻碍了类的刻画能力，但实际上降低了继承体系的复杂度，更有利于推广和使用。

组合和继承作为 Java 中代码复用的两种方式，最主要的区别在于组合将已有的类作为新类的属性，而继承中新类会左右已有类的子类出现。基于这样的区别，编程时组合和继承都可以达到目的的情况下，优先使用组合，因为继承的耦合度相对较大，例如对父类的修改可能会涉及到所有的子类以及对子类的使用。

## 关于多态

多态是与继承同时出现的，通常情况下单纯的继承父类是没有任何意义的，编写子类一定是为了实现父类没有实现的功能，否则完全没必要实现一个子类出来。

我觉得可以简单的将多态理解为生物学上的“变异”，孩子在继承父母基因的同时不是完全的拷贝，而是会发生一定的突变从而表现出与父母不同的性状。Java 中子类继承父类的时候也可以有一些自己独有的变化，比如下面的例子中，父类是没有名字的，但子类每个小狗都有了一个名字。

```java
class Dog {
	private String type = "狗";
}

class ZhongHuaTianYuanQuan extend Dog {
	private String name = "大帅" ;
}

class HaShiQi extend Dog {
	private String name = "小美";
}

```

多态与现实中的变异也存在区别，现实中的物种发生的突变比较多的时候，可能会衍生出一个新的物种来，但是这种情况不会在类的继承中出现，无论子类发生了什么变化，它仍然属于父类的一种。

因为多态不会改变子类的分类，所以任何在使用需要父类的地方，都可以将它的一个子类放入其中，这正是 Java 中子类可以向上转型为父类的原因，无论你是哈士奇还是中华田园犬，当我需要的是一条狗的时候，这两个都是狗，都是可以使用的。同时我们通常无法将父类随便转型为子类，这从逻辑上也是说的通的，当我限定需要一条智商比较高的狗的时候，那么就不是所有狗都能满足我的需求了。

## 关于接口

在继承体系下，每个类必须属于一个分类（如果没有继承会自动继承 Object），通常情况下这样是没问题的，但有时候这样显得有些死板。比如我要钉一个钉子，可是使用锤子，不论是铁锤还是橡皮锤都可以，在极端情况下随便找一块石头都能拿来钉钉子。这种情况下就不太容易刻画了，无论是把石头归到锤子的分类下，还是给锤子和石头搞一个共同的父类，都是不太合适的。

于是乎接口应运而生，只关心具体的行为，我钉钉子的时候只关注手上的工具能不能钉钉子，它到底是锤子，是石头，还是别的什么，这不是我关心的，接口就只这么一种抽象。

```java
interface Strike {
	void strike();
}

class Stone implements Strike {
	public void strike(){
		System.out.println("使用石头敲钉子");
	};
}

class Hammer implements Strike {
	public void strike(){
		System.out.println("使用锤子敲钉子");
	};
}
```

类似于继承中的向上转系，类也可以被转型为它实现的接口，与继承父类相比，Java 中一个类可以实现多个接口，一定上弥补了 Java 中无法多继承的空白，同时比起多继承来说更加合理。继承体系中多继承使得类变得混乱的原因

## 关于内部类

内部类与普通类大体上是类似的，区别在于内部了它定义在其他类的内部，主要解决了两个方面的问题。

一是在编程过程中同一个包内的类无法具有相同的命名，使用内部类的话有点类似于其他语言中命名空间的概念，不同命名空间中类的名称可以相同；二是一些类本身只提供给特定的类使用，并且因为内部类可以访问外部类，那么将其就近定义为内部类就是更好的选择。

匿名类在普通内部类的基础上又进一步简化，有些场合下类只会使用一次，专门取定义以下这样的类是繁琐的，所以出现了匿名内部类。它最大的特点是没有名字，所以定义过好无法对它进行引入，实现了只使用一次的目的。


